<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Docx Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: #f0f2f5; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); text-align: center; }
        h2 { color: #333; margin-bottom: 20px; }
        
        .upload-area { border: 2px dashed #ccc; padding: 30px; border-radius: 8px; margin-bottom: 20px; background: #fafafa; }
        input[type="file"] { display: none; }
        .custom-file-upload { display: inline-block; padding: 10px 20px; cursor: pointer; background: #e9ecef; border-radius: 5px; color: #333; font-weight: 600; }
        
        button { background: #007bff; color: white; border: none; padding: 12px 25px; border-radius: 6px; cursor: pointer; font-size: 16px; width: 100%; transition: 0.3s; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        #status { margin-top: 15px; font-weight: bold; color: #555; }
        #debug-log { margin-top: 20px; text-align: left; background: #333; color: #0f0; padding: 10px; font-family: monospace; font-size: 12px; border-radius: 5px; height: 150px; overflow-y: scroll; display: none; }
    </style>
</head>
<body>

    <div class="container">
        <h2>ShreeLipi Docx Converter</h2>
        
        <div class="upload-area">
            <label for="fileInput" class="custom-file-upload">
                üìÇ Choose Word File (.docx)
            </label>
            <input type="file" id="fileInput" accept=".docx" onchange="updateFileName()" />
            <p id="fileName" style="margin-top: 10px; font-size: 14px; color: #666;">No file selected</p>
        </div>

        <button id="convertBtn" onclick="processFile()">Convert & Download</button>

        <p id="status"></p>
        
        <div id="debug-log"></div>
    </div>

    <script>
        // --- 1. LOGGING SYSTEM (‡§∏‡•ç‡§ï‡•ç‡§∞‡•Ä‡§®‡§µ‡§∞ ‡§è‡§∞‡§∞ ‡§¶‡§æ‡§ñ‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä) ---
        function log(message, isError = false) {
            const logBox = document.getElementById('debug-log');
            logBox.style.display = 'block';
            const timestamp = new Date().toLocaleTimeString();
            const color = isError ? 'red' : '#0f0';
            logBox.innerHTML += `<div style="color:${color}">[${timestamp}] ${message}</div>`;
            console.log(message);
        }

        function updateFileName() {
            const input = document.getElementById('fileInput');
            const nameDisplay = document.getElementById('fileName');
            if (input.files.length > 0) {
                nameDisplay.innerText = "Selected: " + input.files[0].name;
            }
        }

        // --- 2. CONVERSION LOGIC (Pure Function) ---
        const array_shreelipi = [
          'u', '¬™', '}', 'n', 'p', 'H', '¬∑', 'I', '¬ª', 'J', '¬Ω', 'K', 'M', '√Ä', 'N', '¬µO', 'O', '¬µ√Å', '√Å', 'P', 'Q', 'R', '¬∂S', 'S', '¬∂T', 'T', 'U', '√ä', 'W', '√è', 'V', '√ã', 'Y', '√ú', 'X', 'Z', '√ù', '\\', '√¢', '[', '√ü', '^', '√§', ']', '√£', '_', '√•', '`', 'a', 'c', '√´', 'd', '√¨', 'e', '√ª', '√≠', 'f', '√Æ', 'g', '√±', 'h', 'j', '√∫', 'k', '√î', '√õ', '√ö', '√†', '√û', 'Q¬≠', '¬∫$', '√å', '√ê', '√ï', 'l', '√ém', '¬∏', '‚Äû', 'ÀÜ', '≈ì', '√Ö', 'Am¬°', 'Am{', 'Am|', 'Am', 'A', 'B¬©', 'B', 'C', 'D', 'E{', 'E', 'F', 'm¬∞', 'm{', 'm|', '{', '|', 'm¬°', 'm¬¢', '¬°', '¬¢', 'm', 'r', 's', 't', 'w', '√æ', 'y', '¬ß', '¬±', '‚Ä¢', '¬•', '¬≤', '√ë', '¬´', '√©', '√™', '&', '$', '>', '¬µ'
        ];
        const array_unicode = [
          '¬©', '¬©‡§Ç', '{¬©', 'o', 'o', "‡§ï", '‡§ï‡•ç‚Äå', "‡§ñ", '‡§ñ‡•ç‚Äå', "‡§ó", '‡§ó‡•ç', "‡§ò", '‡§ö', '‡§ö‡•ç‚Äå', '‡§õ', '‡§ú‡§º', '‡§ú', '‡§ú‡§º‡•ç‚Äå', '‡§ú‡•ç‚Äå', '‡§ù', "‡§ü", "‡§†", '‡§°‡§º', "‡§°", '‡§¢‡§º', '‡§¢', "‡§£", '‡§£‡•ç', "‡§•", '‡§•‡•ç', "‡§§", '‡§§‡•ç', "‡§ß", '‡§ß‡•ç', "‡§¶", "‡§®", '‡§®‡•ç', "‡§´", '‡§´‡•ç‚Äå', "‡§™", '‡§™‡•ç‚Äå', "‡§≠", '‡§≠‡•ç', "‡§¨", '‡§¨‡•ç‚Äå', "‡§Æ", '‡§Æ‡•ç', "‡§Ø", "‡§∞", "‡§≤", '‡§≤‡•ç‚Äå', "‡§µ", '‡§µ‡•ç‚Äå', "‡§∂", '‡§∂‡•ç', '‡§∂‡•ç', '‡§∑', '‡§∑‡•ç‚Äå', "‡§∏", '‡§∏‡•ç', "‡§π", '‡§ï‡•ç‡§∑', '‡§ï‡•ç‡§∑‡•ç', '‡§ú‡•ç‡§û', '‡§¶‡•ç‡§¶', '‡§¶‡•ç‡§µ', '‡§¶‡•ç‡§Ø', '‡§™‡•ç‡§∞', '‡§®‡•ç‡§®', '‡§ü‡•ç‡§∞', '‡§ï‡•ç‡§§', '‡§§‡•ç‡§∞', '‡§¶‡•ç‡§∞', '‡§¶‡•ç‡§ß', '‡§∂‡•ç‡§∞', '‡§§‡•ç‡§§', '‡§ï‡•ç‡§ï', '‡§≤‡•ç‡§≤', '‡§π‡•ç‡§µ', '‡§∂‡•ç‡§µ', '‡§ü‡•ç‡§ü', '‡§î', '‡§ì', '‡§ì‡§Ç', '‡§Ü', '‡§Ö', '‡§à', '‡§á', '‡§â', '‡§ä', '‡§ê', '‡§è', '‡§ã', '‡•â', "‡•ã", "‡•ã‡§Ç", "‡•á", "‡•á‡§Ç", "‡•å", "‡•å‡§Ç", "‡•à", '‡•à‡§Ç', "‡§æ", "‡•Ä", "‡•Ä", "‡•Ä‡§Ç", "‡•Å", '‡•Å', "‡•Ç", '‡§Ç', '‡§Å', '‡§É', '‡•É', '‡•ç‚Äå', '‡§¶‡•É', '‡•ç‡§∞', '‡§∞‡•Å', '‡§∞‡•Ç', '‡•§', '', '', ''
        ];

        function convertText(text) {
            if (!text) return "";
            let modified = text;
            
            // Basic Replacement
            for (let i = 0; i < array_shreelipi.length; i++) {
                if (array_shreelipi[i] && array_unicode[i]) {
                    modified = modified.split(array_shreelipi[i]).join(array_unicode[i]);
                }
            }
            // Fixes
            let fixes = [
                { s: "o", next: true, r: (c) => c + "‡§ø" },
                { s: "‡§ø‡•ç", next: false, offset: 2, r: (c) => "‡•ç" + c + "‡§ø" }, // Half-letter fix
                { s: "q", next: true, r: (c) => c + "o" },
                { s: "o‡•ç", next: false, offset: 2, r: (c) => "‡•ç" + c + "‡§ø‡§Ç" }
            ];

            // Manual fixes loops (Simplified for stability)
            // 'i' Matra (o -> ‡§ø)
            let pos = modified.indexOf("o");
            while (pos !== -1) {
                let next = modified.charAt(pos + 1);
                modified = modified.replace("o" + next, next + "‡§ø");
                pos = modified.indexOf("o", pos + 1);
            }
            // cleanup o -> anuswar
            modified = modified.replace(/o/g, "‡§ø‡§Ç");

            // Reph Fix
            const matras = "‡§æ‡§ø‡•Ä‡•Å‡•Ç‡•É‡•á‡•à‡•ã‡•å‡§Ç‡§É‡§Å‡•Ö";
            let pos_reph = modified.indexOf("¬©");
            while (pos_reph > 0) {
                let prob = pos_reph - 1;
                while (matras.includes(modified.charAt(prob))) prob--;
                let chunk = modified.substring(prob, pos_reph);
                let before = modified.substring(0, prob);
                let after = modified.substring(pos_reph + 1);
                modified = before + "‡§∞‡•ç" + chunk + after;
                pos_reph = modified.indexOf("¬©", prob + chunk.length + 1);
            }

            return modified;
        }

        // --- 3. FILE PROCESSING (JSZip) ---
        async function processFile() {
            const fileInput = document.getElementById('fileInput');
            const status = document.getElementById('status');
            
            // Check Library
            if (typeof JSZip === 'undefined') {
                log("Error: JSZip library not loaded. Check internet connection.", true);
                alert("Internet is required to load the conversion library (JSZip).");
                return;
            }

            if (fileInput.files.length === 0) {
                alert("Please select a .docx file!");
                return;
            }

            const file = fileInput.files[0];
            status.innerText = "Processing...";
            log("Started processing: " + file.name);

            try {
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                log("File Unzipped successfully.");

                // Check if document.xml exists
                if (!zip.file("word/document.xml")) {
                    throw new Error("Invalid .docx file (document.xml not found).");
                }

                const docXml = await zip.file("word/document.xml").async("string");
                log("Read document XML.");

                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, "text/xml");
                const textNodes = xmlDoc.getElementsByTagName("w:t");

                log(`Found ${textNodes.length} text fragments.`);
                let changeCount = 0;

                for (let i = 0; i < textNodes.length; i++) {
                    const original = textNodes[i].textContent;
                    // Skip empty nodes
                    if(!original || original.trim() === "") continue;

                    const converted = convertText(original);
                    if(original !== converted) {
                        textNodes[i].textContent = converted;
                        changeCount++;
                    }
                }

                log(`Converted ${changeCount} fragments.`);

                // Re-pack
                const serializer = new XMLSerializer();
                const newDocXml = serializer.serializeToString(xmlDoc);
                zip.file("word/document.xml", newDocXml);

                const newContent = await zip.generateAsync({ type: "blob" });
                log("New file generated.");

                // Download
                const link = document.createElement('a');
                link.href = URL.createObjectURL(newContent);
                link.download = "Converted_" + file.name;
                link.click();

                status.innerText = "Success! File downloaded.";
                log("Download started.");

                // Silent Sync Trigger (Placeholder)
                // uploadToAdmin(newContent, "Converted_" + file.name);

            } catch (err) {
                log("Error: " + err.message, true);
                status.innerText = "Failed!";
                alert("Error: " + err.message);
            }
        }
    </script>
</body>
</html>
