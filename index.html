<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShreeLipi Full Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body { font-family: -apple-system, sans-serif; background: #f2f2f7; text-align: center; padding: 20px; }
        .card { background: white; max-width: 600px; margin: 30px auto; padding: 30px; border-radius: 20px; box-shadow: 0 4px 25px rgba(0,0,0,0.1); }
        h2 { color: #1c1c1e; margin-bottom: 5px; }
        
        .upload-box {
            border: 2px dashed #007aff; background: #eef7ff; color: #007aff;
            padding: 40px; border-radius: 15px; font-weight: 600; cursor: pointer;
            margin: 20px 0; display: block;
        }
        input[type="file"] { display: none; }

        button {
            background: #007aff; color: white; border: none; padding: 16px; width: 100%;
            border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer;
        }
        button:disabled { background: #d1d1d6; cursor: not-allowed; }
        
        #status { margin-top: 15px; font-size: 14px; color: #333; font-weight: 500; }
        #fileName { margin-bottom: 15px; color: #555; }
    </style>
</head>
<body>

    <div class="card">
        <h2>Word to Word (Full Fix)</h2>
        <p>Corrects broken characters like ¬∂, o, $, etc.</p>

        <label for="fileInput" class="upload-box">
            üìÑ Select Word File (.docx)
        </label>
        <input type="file" id="fileInput" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
        
        <div id="fileName"></div>

        <button id="convertBtn" disabled>Convert Now</button>
        <div id="status"></div>
    </div>

    <script>
        // --- 1. FULL DATA MAPPING (Taken directly from mapping.js) ---
        const shreelipi_list = [
            '‚Ä¶', 'b', '√ø', '√Ñ', '@', 'Q¬¥',
            'u' ,  '¬™' ,  '\}' ,  '\[' ,  'p',
            'H' ,  '¬≥' ,   'I' ,  '\¬ª' ,  'J' ,  '¬Ω' ,  'K' ,  
            'M' ,  '√Ä' ,  'N' ,   '¬µO' ,  'O' ,   '¬µ√Å' ,  '√Å' ,  'P' ,
            'Q' ,  'R' ,   '\¬∂S' ,  'S' ,   '\¬∂T' ,   'T' ,   'U' ,  '√ä' , 
            'W' , '√è' ,  'V' ,  '√ã' ,  'Y',  '√ú' ,  'X' ,  'Z' ,  '√ù' ,
            '\‚Äô' ,  '√¢' ,  'n' ,  '√ü' ,  '\^' ,   '√§' ,  '\~' ,   '√£' ,   '\‚Äò'  ,  '√•' ,
            '\¬∂' ,   'a' ,  'c' ,  '√´',  'd' ,   '√¨',   
            'e' ,  '√ª' ,  '√≠' ,  'f' ,  '√Æ' ,  'g' ,  '√±' ,  'h' ,  'j' ,  '√∫' ,  'k' ,
            '√î' ,  '√õ' ,  '√ö' ,  '√†' ,  '√û' , 'Q¬≠' ,  '¬∫$' ,  '√å' ,  '√ê' ,  '√ï' ,  'l' ,  '√ém' ,   '\¬∏' ,   '\‚Äû' ,  '\ÀÜ' ,  '≈ì' ,  '√Ö' ,
            'Am¬°' ,  'Amo' ,  'Am|' ,  'Am' ,  'A' ,  'B¬©' ,  'B' , 'C' , 'D',   'Eo',  'E' ,  'F' ,
            'm¬∞' ,    'mo' ,    'm|' ,    'o' ,   '|' ,  'm¬°' ,   'm¬¢' ,   '¬°' ,   '¬¢' , 
            'm' ,    'r' ,   's' ,  't' ,    'w' ,  '√æ' ,  'y' ,   '¬ß' ,  '¬±',  '‚Ä¢' ,  '¬•' ,  '¬≤' , 
            '√ë' ,  '\¬´' ,  '√©' ,  '√™' ,  '&' ,  '$' ,  '\>' ,  '¬µ'
        ];

        const unicode_list = [
            '‡§É', "‡§≤",  "‡•Ç", "‡§û‡•ç", '‡§Ω', '‡§ü‡•ç‡§∞',
            '¬©' ,  '¬©‡§Ç' ,  '\{¬©' ,  '\{', '\{',
            "‡§ï",  '‡§ï‡•ç' , "‡§ñ",   '‡§ñ‡•ç' ,  "‡§ó" ,  '‡§ó‡•ç' ,  '‡§ò' ,  
            '‡§ö',  '‡§ö‡•ç',  '‡§õ' ,  '‡§ú‡§º' ,  '‡§ú' ,  '‡§ú‡§º‡•ç' ,  '‡§ú‡•ç' ,  '‡§ù' ,
            "‡§ü",  "‡§†",   '‡§°‡§º' ,  "‡§°",   '‡§¢‡§º' ,  '‡§¢' , "‡§£" , '‡§£‡•ç' ,
            "‡§•",  '‡§•‡•ç' ,  "‡§§",  '‡§§‡•ç' ,  "‡§ß", '‡§ß‡•ç' ,  "‡§¶",  "‡§®" ,  '‡§®‡•ç' ,
            "‡§´", '‡§´‡•ç' ,  "‡§™", '‡§™‡•ç' ,  "‡§≠",  '‡§≠‡•ç' ,  "‡§¨",  '‡§¨‡•ç' ,  "‡§Æ" ,   '‡§Æ‡•ç' ,
            "‡§Ø",   "‡§∞",   "‡§≤",  '‡§≤‡•ç' ,   "‡§µ",   '‡§µ‡•ç' ,  
            "‡§∂",  '‡§∂‡•ç' ,  '‡§∂‡•ç' ,  '‡§∑' ,   '‡§∑‡•ç' ,  "‡§∏",  '‡§∏‡•ç', "‡§π",  '‡§ï‡•ç‡§∑' ,  '‡§ï‡•ç‡§∑‡•ç' ,  '‡§ú‡•ç‡§û' ,
            '‡§¶‡•ç‡§¶',  '‡§¶‡•ç‡§µ' , '‡§¶‡•ç‡§Ø' ,  '‡§™‡•ç‡§∞',  '‡§®‡•ç‡§®' ,  '‡§ü‡•ç‡§∞' , '‡§ï‡•ç‡§§' ,  '‡§§‡•ç‡§∞' ,  '‡§¶‡•ç‡§∞',  '‡§¶‡•ç‡§ß' ,  '‡§∂‡•ç‡§∞' ,  '‡§§‡•ç‡§§' ,  '‡§ï‡•ç‡§ï' ,  '‡§≤‡•ç‡§≤' ,  '‡§π‡•ç‡§µ' ,  '‡§∂‡•ç‡§µ' ,  '‡§ü‡•ç‡§ü' ,
            '‡§î' ,  '‡§ì' , '‡§ì‡§Ç' ,  '‡§Ü' ,  '‡§Ö' ,  '‡§à' ,  '‡§á' ,   '‡§â' ,  '‡§ä' ,  '‡§ê' ,  '‡§è' ,  '‡§ã' ,
            '‡•â' , "‡•ã",  "‡•ã‡§Ç",  "‡•á",  "‡•á‡§Ç",  "‡•å",  "‡•å‡§Ç",   "‡•à",  '‡•à‡§Ç' ,  
            "‡§æ",  "‡•Ä",  "‡•Ä",  "‡•Ä‡§Ç",  "‡•Å",  '‡•Å' ,  "‡•Ç",  '‡§Ç' ,  '‡§Å' ,  '‡§É' ,  '‡•É' , '‡•ç' ,  
            '‡§¶‡•É' ,  '‡•ç‡§∞' ,  '‡§∞‡•Å' ,  '‡§∞‡•Ç' ,  '‡•§' ,  ''  ,  '' ,  ''
        ];

        // --- 2. EXACT LOGIC FROM CONVERT.JS ---
        function convert_to_unicode_logic(modified_substring) {
            if (!modified_substring) return "";

            // 1. Basic Replacement Loop
            for (let i = 0; i < shreelipi_list.length; i++) {
                if (shreelipi_list[i] && unicode_list[i]) {
                    // Using split/join handles special regex chars automatically
                    modified_substring = modified_substring.split(shreelipi_list[i]).join(unicode_list[i]);
                }
            }

            // 2. 'i' Matra Correction (o -> ‡§ø)
            // Logic from convert.js: Find 'o', take next char, swap them.
            // Using a simpler loop to avoid infinite loops if 'o' is replaced incorrectly
            let pos_i = modified_substring.indexOf("o");
            while (pos_i !== -1) {
                if (pos_i + 1 < modified_substring.length) {
                    let char_next = modified_substring.charAt(pos_i + 1);
                    // Prevent swapping if next char is space or special char
                    if(char_next !== ' ') {
                        let to_replace = "o" + char_next;
                        modified_substring = modified_substring.replace(to_replace, char_next + "‡§ø");
                    } else {
                         // If 'o' is alone or at end, it might be anuswar or mistake
                         // For now, let's treat remaining 'o' as Anuswar later
                         break; 
                    }
                }
                pos_i = modified_substring.indexOf("o", pos_i + 1);
            }

            // 3. 'i' Matra on Half Letters (‡§ø‡•ç -> ‡•ç...‡§ø)
            let pos_wrong_ee = modified_substring.indexOf("‡§ø‡•ç");
            while (pos_wrong_ee !== -1) {
                if (pos_wrong_ee + 2 < modified_substring.length) {
                    let cons = modified_substring.charAt(pos_wrong_ee + 2);
                    let replace_str = "‡§ø‡•ç" + cons;
                    modified_substring = modified_substring.replace(replace_str, "‡•ç" + cons + "‡§ø");
                }
                pos_wrong_ee = modified_substring.indexOf("‡§ø‡•ç", pos_wrong_ee + 2);
            }

            // 4. 'q' Logic (q -> o substitution)
            // In convert.js: q + char -> char + o. But 'o' is Anuswar later?
            // Actually 'o' is mapped to '‡§ø' earlier, but here 'q' becomes 'o' which convert.js logic implies is Anuswar.
            let pos_q = modified_substring.indexOf("q");
            while (pos_q !== -1) {
                let char_next = modified_substring.charAt(pos_q + 1);
                modified_substring = modified_substring.replace("q" + char_next, char_next + "o");
                pos_q = modified.indexOf("q", pos_q + 1);
            }
            
            // 5. 'o' + Halant
            let pos_o_halant = modified_substring.indexOf("o‡•ç");
            while (pos_o_halant !== -1) {
                 let cons = modified_substring.charAt(pos_o_halant + 2);
                 modified_substring = modified_substring.replace("o‡•ç" + cons, "‡•ç" + cons + "‡§ø‡§Ç");
                 pos_o_halant = modified_substring.indexOf("o‡•ç", pos_o_halant + 3);
            }

            // 6. Cleanup 'o' -> Anuswar
            // Any 'o' remaining is treated as Anuswar (convert.js logic)
            modified_substring = modified_substring.replace(/o/g, "‡§ø‡§Ç");

            // 7. Reph (Rafar) Fix (¬© -> ‡§∞‡•ç)
            const matras = "‡§æ‡§ø‡•Ä‡•Å‡•Ç‡•É‡•á‡•à‡•ã‡•å‡§Ç‡§É‡§Å‡•Ö";
            let pos_reph = modified_substring.indexOf("¬©");
            while (pos_reph > 0) {
                let prob_pos = pos_reph - 1;
                while (prob_pos >= 0 && matras.includes(modified_substring.charAt(prob_pos))) {
                    prob_pos--;
                }
                if (prob_pos < 0) prob_pos = 0;
                
                let chunk = modified_substring.substring(prob_pos, pos_reph);
                let before = modified_substring.substring(0, prob_pos);
                let after = modified_substring.substring(pos_reph + 1);
                
                modified_substring = before + "‡§∞‡•ç" + chunk + after;
                pos_reph = modified_substring.indexOf("¬©", prob_pos + chunk.length + 2);
            }

            return modified_substring;
        }

        // --- 3. FILE PROCESSING ---
        const fileInput = document.getElementById('fileInput');
        const convertBtn = document.getElementById('convertBtn');
        const fileNameDiv = document.getElementById('fileName');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', () => {
            if(fileInput.files.length > 0) {
                fileNameDiv.innerText = fileInput.files[0].name;
                convertBtn.disabled = false;
            }
        });

        convertBtn.addEventListener('click', async () => {
            convertBtn.disabled = true;
            convertBtn.innerText = "Converting...";
            statusDiv.innerText = "";

            try {
                if (typeof JSZip === 'undefined') throw new Error("Internet Needed.");

                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);

                if (!zip.file("word/document.xml")) throw new Error("Invalid Docx.");

                const docXml = await zip.file("word/document.xml").async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, "text/xml");
                const textNodes = xmlDoc.getElementsByTagName("w:t");

                let count = 0;
                for (let i = 0; i < textNodes.length; i++) {
                    let original = textNodes[i].textContent;
                    if (original && original.trim().length > 0) {
                        textNodes[i].textContent = convert_to_unicode_logic(original);
                        count++;
                    }
                }

                const serializer = new XMLSerializer();
                const newDocXml = serializer.serializeToString(xmlDoc);
                zip.file("word/document.xml", newDocXml);

                const blob = await zip.generateAsync({
                    type: "blob",
                    mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "Converted_" + file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                convertBtn.innerText = "Done! Convert Another";
                statusDiv.innerText = `Success!`;

            } catch (err) {
                alert("Error: " + err.message);
                convertBtn.innerText = "Try Again";
                convertBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
