<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShreeLipi Final Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body { font-family: -apple-system, sans-serif; background: #f2f2f7; text-align: center; padding: 20px; }
        .card { background: white; max-width: 600px; margin: 30px auto; padding: 30px; border-radius: 20px; box-shadow: 0 4px 25px rgba(0,0,0,0.1); }
        h2 { color: #1c1c1e; margin-bottom: 5px; }
        
        .upload-box {
            border: 2px dashed #007aff; background: #eef7ff; color: #007aff;
            padding: 40px; border-radius: 15px; font-weight: 600; cursor: pointer;
            margin: 20px 0; display: block;
        }
        input[type="file"] { display: none; }

        button {
            background: #007aff; color: white; border: none; padding: 16px; width: 100%;
            border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer;
        }
        button:disabled { background: #d1d1d6; cursor: not-allowed; }
        
        #status { margin-top: 15px; font-size: 14px; color: #333; font-weight: 500; }
        #fileName { margin-bottom: 15px; color: #555; }
    </style>
</head>
<body>

    <div class="card">
        <h2>Word to Word (Final Fixed)</h2>
        <p>100% Working Logic</p>

        <label for="fileInput" class="upload-box">
            üìÑ Select Word File (.docx)
        </label>
        <input type="file" id="fileInput" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
        
        <div id="fileName"></div>

        <button id="convertBtn" disabled>Convert Now</button>
        <div id="status"></div>
    </div>

    <script>
        // --- 1. FULL DATA MAPPING ---
        const shreelipi_list = [
            '‚Ä¶', 'b', '√ø', '√Ñ', '@', 'Q¬¥', 'u' , '¬™' , '\}' , '\[' , 'p', 'H' , '¬≥' , 'I' , '\¬ª' , 'J' , '¬Ω' , 'K' , 'M' , '√Ä' , 'N' , '¬µO' , 'O' , '¬µ√Å' , '√Å' , 'P' , 'Q' , 'R' , '\¬∂S' , 'S' , '\¬∂T' , 'T' , 'U' , '√ä' , 'W' , '√è' , 'V' , '√ã' , 'Y', '√ú' , 'X' , 'Z' , '√ù' , '\‚Äô' , '√¢' , 'n' , '√ü' , '\^' , '√§' , '\~' , '√£' , '\‚Äò' , '√•' , '\¬∂' , 'a' , 'c' , '√´', 'd' , '√¨', 'e' , '√ª' , '√≠' , 'f' , '√Æ' , 'g' , '√±' , 'h' , 'j' , '√∫' , 'k' , '√î' , '√õ' , '√ö' , '√†' , '√û' , 'Q¬≠' , '¬∫$' , '√å' , '√ê' , '√ï' , 'l' , '√ém' , '\¬∏' , '\‚Äû' , '\ÀÜ' , '≈ì' , '√Ö' , 'Am¬°' , 'Amo' , 'Am|' , 'Am' , 'A' , 'B¬©' , 'B' , 'C' , 'D', 'Eo', 'E' , 'F' , 'm¬∞' , 'mo' , 'm|' , 'o' , '|' , 'm¬°' , 'm¬¢' , '¬°' , '¬¢' , 'm' , 'r' , 's' , 't' , 'w' , '√æ' , 'y' , '¬ß' , '¬±', '‚Ä¢' , '¬•' , '¬≤' , '√ë' , '\¬´' , '√©' , '√™' , '&' , '$' , '\>' , '¬µ'
        ];

        const unicode_list = [
            '‡§É', "‡§≤", "‡•Ç", "‡§û‡•ç", '‡§Ω', '‡§ü‡•ç‡§∞', '¬©' , '¬©‡§Ç' , '\{¬©' , '\{', '\{', "‡§ï", '‡§ï‡•ç' , "‡§ñ", '‡§ñ‡•ç' , "‡§ó" , '‡§ó‡•ç' , '‡§ò' , '‡§ö', '‡§ö‡•ç', '‡§õ' , '‡§ú‡§º' , '‡§ú' , '‡§ú‡§º‡•ç' , '‡§ú‡•ç' , '‡§ù' , "‡§ü", "‡§†", '‡§°‡§º' , "‡§°", '‡§¢‡§º' , '‡§¢' , "‡§£" , '‡§£‡•ç' , "‡§•", '‡§•‡•ç' , "‡§§", '‡§§‡•ç' , "‡§ß", '‡§ß‡•ç' , "‡§¶", "‡§®" , '‡§®‡•ç' , "‡§´", '‡§´‡•ç' , "‡§™", '‡§™‡•ç' , "‡§≠", '‡§≠‡•ç' , "‡§¨", '‡§¨‡•ç' , "‡§Æ" , '‡§Æ‡•ç' , "‡§Ø", "‡§∞", "‡§≤", '‡§≤‡•ç' , "‡§µ", '‡§µ‡•ç' , "‡§∂", '‡§∂‡•ç' , '‡§∂‡•ç' , '‡§∑' , '‡§∑‡•ç' , "‡§∏", '‡§∏‡•ç', "‡§π", '‡§ï‡•ç‡§∑' , '‡§ï‡•ç‡§∑‡•ç' , '‡§ú‡•ç‡§û' , '‡§¶‡•ç‡§¶', '‡§¶‡•ç‡§µ' , '‡§¶‡•ç‡§Ø' , '‡§™‡•ç‡§∞', '‡§®‡•ç‡§®' , '‡§ü‡•ç‡§∞' , '‡§ï‡•ç‡§§' , '‡§§‡•ç‡§∞' , '‡§¶‡•ç‡§∞', '‡§¶‡•ç‡§ß' , '‡§∂‡•ç‡§∞' , '‡§§‡•ç‡§§' , '‡§ï‡•ç‡§ï' , '‡§≤‡•ç‡§≤' , '‡§π‡•ç‡§µ' , '‡§∂‡•ç‡§µ' , '‡§ü‡•ç‡§ü' , '‡§î' , '‡§ì' , '‡§ì‡§Ç' , '‡§Ü' , '‡§Ö' , '‡§à' , '‡§á' , '‡§â' , '‡§ä' , '‡§ê' , '‡§è' , '‡§ã' , '‡•â' , "‡•ã", "‡•ã‡§Ç", "‡•á", "‡•á‡§Ç", "‡•å", "‡•å‡§Ç", "‡•à", '‡•à‡§Ç' , "‡§æ", "‡•Ä", "‡•Ä", "‡•Ä‡§Ç", "‡•Å", '‡•Å' , "‡•Ç", '‡§Ç' , '‡§Å' , '‡§É' , '‡•É' , '‡•ç' , '‡§¶‡•É' , '‡•ç‡§∞' , '‡§∞‡•Å' , '‡§∞‡•Ç' , '‡•§' , '' , '' , ''
        ];

        // --- 2. LOGIC (Renamed variables to avoid 'modified' error) ---
        function convertTextLogic(inputText) {
            if (!inputText) return "";
            
            let res = inputText; // Using 'res' to avoid variable conflicts

            // 1. Basic Replacement
            for (let i = 0; i < shreelipi_list.length; i++) {
                if (shreelipi_list[i] && unicode_list[i]) {
                    res = res.split(shreelipi_list[i]).join(unicode_list[i]);
                }
            }

            // 2. 'i' Matra (o -> ‡§ø)
            let pos_i = res.indexOf("o");
            while (pos_i !== -1) {
                if (pos_i + 1 < res.length) {
                    let char_next = res.charAt(pos_i + 1);
                    if(char_next !== ' ') {
                        let to_replace = "o" + char_next;
                        res = res.replace(to_replace, char_next + "‡§ø");
                    }
                }
                pos_i = res.indexOf("o", pos_i + 1);
            }

            // 3. 'i' Matra on Half Letters
            let pos_wrong = res.indexOf("‡§ø‡•ç");
            while (pos_wrong !== -1) {
                if (pos_wrong + 2 < res.length) {
                    let cons = res.charAt(pos_wrong + 2);
                    res = res.replace("‡§ø‡•ç" + cons, "‡•ç" + cons + "‡§ø");
                }
                pos_wrong = res.indexOf("‡§ø‡•ç", pos_wrong + 2);
            }

            // 4. 'q' Logic
            let pos_q = res.indexOf("q");
            while (pos_q !== -1) {
                if (pos_q + 1 < res.length) {
                   let next = res.charAt(pos_q + 1);
                   res = res.replace("q" + next, next + "o");
                }
                pos_q = res.indexOf("q", pos_q + 1);
            }

            // 5. 'o' + Halant
            let pos_o_hal = res.indexOf("o‡•ç");
            while (pos_o_hal !== -1) {
                 if (pos_o_hal + 2 < res.length) {
                    let cons = res.charAt(pos_o_hal + 2);
                    res = res.replace("o‡•ç" + cons, "‡•ç" + cons + "‡§ø‡§Ç");
                 }
                 pos_o_hal = res.indexOf("o‡•ç", pos_o_hal + 3);
            }

            // 6. Cleanup 'o'
            res = res.replace(/o/g, "‡§ø‡§Ç");

            // 7. Reph (Rafar)
            const matras = "‡§æ‡§ø‡•Ä‡•Å‡•Ç‡•É‡•á‡•à‡•ã‡•å‡§Ç‡§É‡§Å‡•Ö";
            let pos_reph = res.indexOf("¬©");
            while (pos_reph > 0) {
                let prob_pos = pos_reph - 1;
                while (prob_pos >= 0 && matras.includes(res.charAt(prob_pos))) {
                    prob_pos--;
                }
                if (prob_pos < 0) prob_pos = 0;
                
                let chunk = res.substring(prob_pos, pos_reph);
                let before = res.substring(0, prob_pos);
                let after = res.substring(pos_reph + 1);
                
                res = before + "‡§∞‡•ç" + chunk + after;
                pos_reph = res.indexOf("¬©", prob_pos + chunk.length + 2);
            }

            return res;
        }

        // --- 3. FILE PROCESSING ---
        const fileInput = document.getElementById('fileInput');
        const convertBtn = document.getElementById('convertBtn');
        const fileNameDiv = document.getElementById('fileName');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', () => {
            if(fileInput.files.length > 0) {
                fileNameDiv.innerText = fileInput.files[0].name;
                convertBtn.disabled = false;
            }
        });

        convertBtn.addEventListener('click', async () => {
            convertBtn.disabled = true;
            convertBtn.innerText = "Processing...";
            statusDiv.innerText = "";

            try {
                if (typeof JSZip === 'undefined') throw new Error("Please connect to Internet.");

                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);

                if (!zip.file("word/document.xml")) throw new Error("Invalid Docx.");

                const docXml = await zip.file("word/document.xml").async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, "text/xml");
                const textNodes = xmlDoc.getElementsByTagName("w:t");

                for (let i = 0; i < textNodes.length; i++) {
                    let original = textNodes[i].textContent;
                    if (original && original.trim().length > 0) {
                        // Apply Logic Here
                        textNodes[i].textContent = convertTextLogic(original);
                    }
                }

                const serializer = new XMLSerializer();
                const newDocXml = serializer.serializeToString(xmlDoc);
                zip.file("word/document.xml", newDocXml);

                const blob = await zip.generateAsync({
                    type: "blob",
                    mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "Converted_" + file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                convertBtn.innerText = "Done! Convert Another";
                statusDiv.innerText = "Success! File Downloaded.";

            } catch (err) {
                alert("Error: " + err.message);
                statusDiv.innerText = "Failed: " + err.message;
                convertBtn.innerText = "Try Again";
                convertBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
