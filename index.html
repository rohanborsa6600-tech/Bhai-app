<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShreeLipi Mega Converter (V12)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body { font-family: -apple-system, sans-serif; background: #eef2f5; text-align: center; padding: 20px; }
        .card { background: white; max-width: 650px; margin: 20px auto; padding: 30px; border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        h2 { color: #2c3e50; margin-bottom: 5px; }
        p { color: #7f8c8d; font-size: 14px; margin-bottom: 25px; }
        
        .upload-area {
            border: 2px dashed #3498db; background: #f0f8ff; color: #2980b9;
            padding: 35px; border-radius: 12px; font-weight: 600; cursor: pointer;
            display: block; margin-bottom: 20px;
        }
        input[type="file"] { display: none; }

        button {
            background: #27ae60; color: white; border: none; padding: 16px; width: 100%;
            border-radius: 10px; font-size: 18px; font-weight: 600; cursor: pointer;
        }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }
        
        #status { margin-top: 15px; font-size: 15px; font-weight: 500; }
    </style>
</head>
<body>

    <div class="card">
        <h2>Word to Word (V12 - Mega Mapping)</h2>
        <p>Includes Jodakshare (‡§ï‡•ç‡§ï, ‡§¶‡•ç‡§ß, ‡§∂‡•ç‡§∞) + Special Fixes.</p>

        <label for="fileInput" class="upload-area">
            üìÇ Select Word File (.docx)
        </label>
        <input type="file" id="fileInput" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
        
        <div id="fileName" style="margin-bottom: 15px; color: #555;"></div>
        <button id="convertBtn" disabled>Convert Now</button>
        <div id="status"></div>
    </div>

    <script>
        // --- 1. THE MEGA LIST (Sorted by Priority automatically in logic) ---
        // Format: [ShreeLipi_Code, Unicode]
        const mapping_db = [
            // SPECIAL / PUNCTUATION
            ['‚Ä¶', '‡§É'], ['b', '‡§≤'], ['√ø', '‡•Ç'], ['√Ñ', '‡§û‡•ç'], ['@', '‡§Ω'], ['Q¬¥', '‡§ü‡•ç‡§∞'],
            ['u', '¬©'], ['¬™', '¬©‡§Ç'], ['}', '{¬©'], ['[', '{'], ['p', '‡§ï'], ['H', '‡§ï‡•ç'],
            ['¬≥', '‡§ñ'], ['I', '‡§ñ‡•ç'], ['¬ª', '‡§ó'], ['J', '‡§ó‡•ç'], ['¬Ω', '‡§ò'], ['K', '‡§ö'],
            ['M', '‡§ö‡•ç'], ['√Ä', '‡§õ'], ['N', '‡§ú‡§º'], ['¬µO', '‡§ú'], ['O', '‡§ú‡§º‡•ç'], ['¬µ√Å', '‡§ú‡•ç'],
            ['√Å', '‡§ù'], ['P', '‡§ü'], ['Q', '‡§†'], ['R', '‡§°‡§º'], ['¬∂S', '‡§°'], ['S', '‡§¢‡§º'],
            ['¬∂T', '‡§¢'], ['T', '‡§£'], ['U', '‡§£‡•ç'], ['√ä', '‡§•'], ['W', '‡§•‡•ç'], ['√è', '‡§§'],
            ['V', '‡§§‡•ç'], ['√ã', '‡§ß'], ['Y', '‡§ß‡•ç'], ['√ú', '‡§¶'], ['X', '‡§®'], ['Z', '‡§®‡•ç'],
            ['√ù', '‡§´'], ['‚Äô', '‡§´‡•ç'], ['√¢', '‡§™'], ['n', '‡§™‡•ç'], ['√ü', '‡§≠'], ['^', '‡§≠‡•ç'],
            ['√§', '‡§¨'], ['~', '‡§¨‡•ç'], ['√£', '‡§Æ'], ['‚Äò', '‡§Æ‡•ç'], ['√•', '‡§Ø'], ['¬∂', '‡§∞'],
            ['a', '‡§≤'], ['c', '‡§≤‡•ç'], ['√´', '‡§µ'], ['d', '‡§µ‡•ç'], ['√¨', '‡§∂'], ['e', '‡§∂‡•ç'],
            ['√ª', '‡§∂‡•ç'], ['√≠', '‡§∑'], ['f', '‡§∑‡•ç'], ['√Æ', '‡§∏'], ['g', '‡§∏‡•ç'], ['√±', '‡§π'],
            ['h', '‡§ï‡•ç‡§∑'], ['j', '‡§ï‡•ç‡§∑‡•ç'], ['√∫', '‡§ú‡•ç‡§û'], ['k', '‡§¶‡•ç‡§¶'], ['√î', '‡§¶‡•ç‡§µ'],
            ['√õ', '‡§¶‡•ç‡§Ø'], ['√ö', '‡§™‡•ç‡§∞'], ['√†', '‡§®‡•ç‡§®'], ['√û', '‡§ü‡•ç‡§∞'], ['Q¬≠', '‡§ï‡•ç‡§§'],
            ['¬∫$', '‡§§‡•ç‡§∞'], ['√å', '‡§¶‡•ç‡§∞'], ['√ê', '‡§¶‡•ç‡§ß'], ['√ï', '‡§∂‡•ç‡§∞'], ['l', '‡§§‡•ç‡§§'],
            ['√ém', '‡§ï‡•ç‡§ï'], ['¬∏', '‡§≤‡•ç‡§≤'], ['‚Äû', '‡§π‡•ç‡§µ'], ['ÀÜ', '‡§∂‡•ç‡§µ'], ['≈ì', '‡§ü‡•ç‡§ü'],
            ['√Ö', '‡§î'], ['Am¬°', '‡§ì'], ['Amo', '‡§ì‡§Ç'], ['Am|', '‡§Ü'], ['Am', '‡§Ö'],
            ['A', '‡§à'], ['B¬©', '‡§á'], ['B', '‡§â'], ['C', '‡§ä'], ['D', '‡§ê'], ['Eo', '‡§è'],
            ['E', '‡§ã'], ['F', '‡•â'], ['m¬∞', '‡•ã'], ['mo', '‡•ã‡§Ç'], ['m|', '‡•á'], ['o', '‡•á‡§Ç'],
            ['|', '‡•å'], ['m¬°', '‡•å‡§Ç'], ['m¬¢', '‡•à'], ['¬°', '‡•à‡§Ç'], ['¬¢', '‡§æ'], ['m', '‡•Ä'],
            ['r', '‡•Ä'], ['s', '‡•Ä‡§Ç'], ['t', '‡•Å'], ['w', '‡•Å'], ['√æ', '‡•Ç'], ['y', '‡§Ç'],
            ['¬ß', '‡§Å'], ['¬±', '‡§É'], ['‚Ä¢', '‡•É'], ['¬•', '‡•ç'], ['¬≤', '‡§¶‡•É'], ['√ë', '‡•ç‡§∞'],
            ['¬´', '‡§∞‡•Å'], ['√©', '‡§∞‡•Ç'], ['√™', '‡•§'], ['&', '‡•§'], ['>', ''], ['¬µ', ''],
            
            // YOUR SPECIFIC FIXES (Added to DB)
            ['$', '‡§≥'], ['G', '‡§ú'], ['L', '‡§ß'], ['v', '‡•à'], ['x', '‡•Ö'], 
            ['%', '‡•Ñ'], ['=', '.'], ['(', '('], [')', ')'], ['√∑', '‡§π‡•ç'], ['¬£', '‡•Ä'],
            
            // COMMON JODAKSHARE (High Priority)
            ['Fk', '‡§∑‡•ç‡§ï'], ['F¬µk', '‡§∑‡•ç‡§´'], ['Fp', '‡§∑‡•ç‡§™'], ['Fhm', '‡§∑‡•ç‡§Æ'], ['Fh', '‡§∑‡•ç‡§Æ'],
            ['Sp', '‡§∑‡•ç‡§ü'], ['S√ß', '‡§∑‡•ç‡§†'], ['nj', '‡§™‡•ç‡§§'], ['n√ß', '‡§™‡•ç‡§•'], ['√ß', '‡§∑‡•ç‡§†'],
            ['√É', '‡§û‡•ç‡§ú'], ['√é', '‡§ï‡•ç'], ['√è', '‡§ï‡•ç‡§§'], ['√ê', '‡§¶‡•ç‡§ß'], ['√ë', '‡•ç‡§∞'],
            ['√í', '‡§°‡•ç‡§¢'], ['√ì', '‡§∂‡•ç‡§∞'], ['√î', '‡§¶‡•ç‡§µ'], ['√ï', '‡§∂‡•ç‡§∞'], ['√ñ', '‡§∂‡•ç‡§µ'],
            ['√ó', '‡§∂‡•ç‡§ö'], ['√ò', '‡§∑‡•ç‡§ü'], ['√ô', '‡§∑‡•ç‡§†'], ['√ö', '‡§™‡•ç‡§∞'], ['√õ', '‡§¶‡•ç‡§Ø'],
            ['√ú', '‡§¶'], ['√ù', '‡§´'], ['√û', '‡§ü‡•ç‡§∞'], ['√ü', '‡§≠'], ['√†', '‡§®‡•ç‡§®'],
            ['√°', '‡§≤‡•ç‡§≤‡•ç'], ['√¢', '‡§™'], ['√£', '‡§Æ'], ['√§', '‡§¨'], ['√•', '‡§Ø'],
            ['√¶', '‡§∞‡•ç‚Äç'], ['√ß', '‡§∑‡•ç‡§†'], ['√®', '‡§∑‡•ç‡§†'], ['√©', '‡§∞‡•Ç'], ['√™', '‡•§'],
            ['√´', '‡§µ'], ['√¨', '‡§∂'], ['√≠', '‡§∑'], ['√Æ', '‡§∏'], ['√Ø', '‡§π'],
            ['√∞', '‡§≥'], ['√±', '‡§π'], ['√≤', '‡§≥'], ['√≥', '‡§ï‡•ç‡§∑'], ['√¥', '‡§ú‡•ç‡§û']
        ];

        // Sort Mapping by Length (Desc) - IMPORTANT!
        // This ensures '‡§ï‡•ç‡§ï' (longer code) is replaced before '‡§ï' (shorter code)
        mapping_db.sort((a, b) => b[0].length - a[0].length);

        function convertText(inputText) {
            if (!inputText) return "";
            let res = inputText;

            // --- 0. PRE-CLEANING (Your specific quirks) ---
            res = res.split('|').join('‡§æ');
            res = res.split('i').join('‡•Ä');
            // $ is in the mapping list now as ‡§≥, but split/join is safer for single chars
            res = res.split('$').join('‡§≥'); 

            // --- 1. VELAANTI SWAP LOGIC (Specific to Matras before Chars) ---
            // { -> ‡§ø
            let pos_curly = res.indexOf("{");
            while (pos_curly !== -1) {
                if (pos_curly + 1 < res.length) {
                    let next = res.charAt(pos_curly + 1);
                    if (next !== ' ' && next !== '¬©') res = res.replace("{" + next, next + "‡§ø");
                }
                pos_curly = res.indexOf("{", pos_curly + 1);
            }
            
            // > -> ‡§ø
            let pos_grt = res.indexOf(">");
            while (pos_grt !== -1) {
                if (pos_grt + 1 < res.length) {
                    let next = res.charAt(pos_grt + 1);
                    if (next !== ' ' && next !== '¬©') res = res.replace(">" + next, next + "‡§ø");
                }
                pos_grt = res.indexOf(">", pos_grt + 1);
            }

            // --- 2. MAIN MAPPING LOOP ---
            for (let i = 0; i < mapping_db.length; i++) {
                const shree = mapping_db[i][0];
                const uni = mapping_db[i][1];
                if (shree && uni) {
                     // Using split/join handles special regex characters in ShreeLipi codes
                     res = res.split(shree).join(uni);
                }
            }

            // --- 3. POST-FIXES (Matra Corrections) ---

            // 'o' Matra (Standard)
            let pos_o = res.indexOf("o");
            while (pos_o !== -1) {
                if (pos_o + 1 < res.length) {
                    let next = res.charAt(pos_o + 1);
                    if (next !== ' ' && next !== '‡•ç') res = res.replace("o" + next, next + "‡§ø");
                }
                pos_o = res.indexOf("o", pos_o + 1);
            }

            // 'q' -> 'o'
            let pos_q = res.indexOf("q");
            while (pos_q !== -1) {
                 if (pos_q + 1 < res.length) {
                    let next = res.charAt(pos_q + 1);
                    res = res.replace("q" + next, next + "o");
                 }
                 pos_q = res.indexOf("q", pos_q + 1);
            }

            // Half Letter Matra (‡§ø‡•ç -> ‡•ç...‡§ø)
            let pos_half = res.indexOf("‡§ø‡•ç");
            while (pos_half !== -1) {
                if (pos_half + 2 < res.length) {
                    let cons = res.charAt(pos_half + 2);
                    res = res.replace("‡§ø‡•ç" + cons, "‡•ç" + cons + "‡§ø");
                }
                pos_half = res.indexOf("‡§ø‡•ç", pos_half + 2);
            }

            // 'o' + Halant
            let pos_oh = res.indexOf("o‡•ç");
            while (pos_oh !== -1) {
                if (pos_oh + 2 < res.length) {
                    let cons = res.charAt(pos_oh + 2);
                    res = res.replace("o‡•ç" + cons, "‡•ç" + cons + "‡§ø‡§Ç");
                }
                pos_oh = res.indexOf("o‡•ç", pos_oh + 3);
            }

            // Cleanup 'o'
            res = res.replace(/o/g, "‡§ø‡§Ç");

            // Rafar Logic: ¬© -> ‡§∞‡•ç
            const matras = "‡§æ‡§ø‡•Ä‡•Å‡•Ç‡•É‡•á‡•à‡•ã‡•å‡§Ç‡§É‡§Å‡•Ö";
            let pos_reph = res.indexOf("¬©");
            while (pos_reph > 0) {
                let prob = pos_reph - 1;
                while (prob >= 0 && matras.includes(res.charAt(prob))) prob--;
                if (prob < 0) prob = 0;
                let chunk = res.substring(prob, pos_reph);
                res = res.substring(0, prob) + "‡§∞‡•ç" + chunk + res.substring(pos_reph + 1);
                pos_reph = res.indexOf("¬©", prob + chunk.length + 2);
            }
            
            // Tilde (~) -> ‡§∞‡•ç
            let pos_tilde = res.indexOf("~");
             while (pos_tilde > 0) {
                let prob = pos_tilde - 1;
                while (prob >= 0 && matras.includes(res.charAt(prob))) prob--;
                if (prob < 0) prob = 0;
                let chunk = res.substring(prob, pos_tilde);
                res = res.substring(0, prob) + "‡§∞‡•ç" + chunk + res.substring(pos_tilde + 1);
                pos_tilde = res.indexOf("~", prob + chunk.length + 2);
            }

            return res;
        }

        // --- UI HANDLERS ---
        const fileInput = document.getElementById('fileInput');
        const convertBtn = document.getElementById('convertBtn');
        const fileNameDiv = document.getElementById('fileName');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', () => {
            if(fileInput.files.length > 0) {
                fileNameDiv.innerText = "Selected: " + fileInput.files[0].name;
                convertBtn.disabled = false;
            }
        });

        convertBtn.addEventListener('click', async () => {
            convertBtn.disabled = true;
            convertBtn.innerText = "Processing...";
            
            try {
                if (typeof JSZip === 'undefined') throw new Error("Internet Needed.");
                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                if (!zip.file("word/document.xml")) throw new Error("Invalid Docx.");
                const docXml = await zip.file("word/document.xml").async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, "text/xml");
                const textNodes = xmlDoc.getElementsByTagName("w:t");

                for (let i = 0; i < textNodes.length; i++) {
                    let original = textNodes[i].textContent;
                    if (original && original.trim().length > 0) {
                        textNodes[i].textContent = convertText(original);
                    }
                }

                const serializer = new XMLSerializer();
                const newDocXml = serializer.serializeToString(xmlDoc);
                zip.file("word/document.xml", newDocXml);
                const blob = await zip.generateAsync({type: "blob", mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"});
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "MegaConvert_" + file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                convertBtn.innerText = "Done! Downloaded.";
                statusDiv.innerText = "Success! Mega Mapping Applied.";
                statusDiv.style.color = "green";
                setTimeout(() => convertBtn.disabled = false, 2000);

            } catch (err) {
                alert("Error: " + err.message);
                convertBtn.innerText = "Try Again";
                convertBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
