<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShreeLipi V18 (Master Fix)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body { font-family: -apple-system, sans-serif; background: #f0f2f5; text-align: center; padding: 20px; }
        .card { background: white; max-width: 650px; margin: 30px auto; padding: 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        h2 { color: #2d3436; margin-bottom: 5px; }
        p { color: #636e72; font-size: 14px; margin-bottom: 30px; }
        
        .upload-area {
            border: 2px dashed #0984e3; background: #eef8ff; color: #0984e3;
            padding: 40px; border-radius: 14px; font-weight: 600; cursor: pointer;
            display: block; margin-bottom: 25px;
        }
        input[type="file"] { display: none; }

        button {
            background: #00b894; color: white; border: none; padding: 18px; width: 100%;
            border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer;
        }
        button:disabled { background: #b2bec3; cursor: not-allowed; }
        
        #status { margin-top: 20px; font-size: 15px; font-weight: 500; }
    </style>
</head>
<body>

    <div class="card">
        <h2>Word to Word (V18 - Master)</h2>
        <p>Fixed: Ã¼->à¤¶à¥à¤š, Ã·->à¤¹à¥à¤®, Ã¶->à¤‚ (Anuswar). 100% Done.</p>

        <label for="fileInput" class="upload-area">
            ðŸ“‚ Tap to Select Word File
        </label>
        <input type="file" id="fileInput" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
        
        <div id="fileName" style="margin-bottom: 15px; color: #555;"></div>
        <button id="convertBtn" disabled>Convert Now</button>
        <div id="status"></div>
    </div>

    <script>
        // --- 1. STABLE MAPPING (V17 Base) ---
        const shreelipi_list = ['â€¦','b','Ã¿','Ã„','@','QÂ´','u','Âª','}','[','p','H','Â³','I','Â»','J','Â½','K','M','Ã€','N','ÂµO','O','ÂµÃ','Ã','P','Q','R','Â¶S','S','Â¶T','T','U','ÃŠ','W','Ã','V','Ã‹','Y','Ãœ','X','Z','Ã','â€™','Ã¢','n','ÃŸ','^','Ã¤','~','Ã£','â€˜','Ã¥','Â¶','a','c','Ã«','d','Ã¬','e','Ã»','Ã­','f','Ã®','g','Ã±','h','j','Ãº','k','Ã”','Ã›','Ãš','Ã ','Ãž','QÂ­','Âº$','ÃŒ','Ã','Ã•','l','ÃŽm','Â¸','â€ž','Ë†','Å“','Ã…','AmÂ¡','Amo','Am|','Am','A','BÂ©','B','C','D','Eo','E','F','mÂ°','mo','m|','o','|','mÂ¡','mÂ¢','Â¡','Â¢','m','r','s','t','w','Ã¾','y','Â§','Â±','â€¢','Â¥','Â²','Ã‘','Â«','Ã©','Ãª','&','$','>','Âµ',
        'G', 'L', 'v', 'x', '%', '=', '(', ')', 'Ã·', 'Â£', 'Â¾', 'Â¨', 'Ã†', 'Ã‡', 'ÃŽ', 'Ã',
        // NEW FIXES V18
        'Ã¼', 'Ã¶'];
        
        const unicode_list = ['à¤ƒ',"à¤²","à¥‚","à¤žà¥",'à¤½','à¤Ÿà¥à¤°','Â©','Â©à¤‚','{Â©','{','{',"à¤•",'à¤•à¥',"à¤–",'à¤–à¥',"à¤—",'à¤—à¥',"à¤˜",'à¤š','à¤šà¥','à¤›','à¤œà¤¼','à¤œ','à¤œà¤¼à¥','à¤œà¥','à¤',"à¤Ÿ","à¤ ",'à¤¡à¤¼',"à¤¡",'à¤¢à¤¼','à¤¢',"à¤£",'à¤£à¥',"à¤¥",'à¤¥à¥',"à¤¤",'à¤¤à¥',"à¤§",'à¤§à¥',"à¤¦","à¤¨",'à¤¨à¥',"à¤«",'à¤«à¥',"à¤ª",'à¤ªà¥',"à¤­",'à¤­à¥',"à¤¬",'à¤¬à¥',"à¤®",'à¤®à¥',"à¤¯","à¤°","à¤²",'à¤²à¥',"à¤µ",'à¤µà¥',"à¤¶",'à¤¶à¥','à¤¶à¥',"à¤·",'à¤·à¥',"à¤¸",'à¤¸à¥',"à¤¹",'à¤•à¥à¤·','à¤•à¥à¤·à¥','à¤œà¥à¤ž','à¤¦à¥à¤¦','à¤¦à¥à¤µ','à¤¦à¥à¤¯','à¤ªà¥à¤°','à¤¨à¥à¤¨','à¤Ÿà¥à¤°','à¤•à¥à¤¤','à¤¤à¥à¤°','à¤¦à¥à¤°','à¤¦à¥à¤§','à¤¶à¥à¤°','à¤¤à¥à¤¤','à¤•à¥à¤•','à¤²à¥à¤²','à¤¹à¥à¤µ','à¤¶à¥à¤µ','à¤Ÿà¥à¤Ÿ','à¤”','à¤“','à¤“à¤‚','à¤†','à¤…','à¤ˆ','à¤‡','à¤‰','à¤Š','à¤','à¤','à¤‹','à¥‰',"à¥‹","à¥‹à¤‚","à¥‡","à¥‡à¤‚","à¥Œ","à¥Œà¤‚","à¥ˆ",'à¥ˆà¤‚',"à¤¾","à¥€","à¥€","à¥€à¤‚","à¥",'à¥',"à¥‚",'à¤‚','à¤','à¤ƒ','à¥ƒ','à¥','à¤¦à¥ƒ','à¥à¤°','à¤°à¥','à¤°à¥‚','à¥¤','à¥¤','','', 
        'à¤œ', 'à¤§', 'à¥ˆ', 'à¥…', 'à¥„', '.', '(', ')', 'à¤¹à¥à¤®', 'à¥€', 'à¤—à¥à¤¨', 'à¥à¤¯', 'à¤°à¥â€', 'à¤·à¥à¤Ÿ', 'à¤¤à¥à¤¤', 'à¤•à¥à¤¤',
        // NEW MAPPINGS
        'à¤¶à¥à¤š', 'à¤‚'];

        function convertText(inputText) {
            if (!inputText) return "";
            let res = inputText;

            // --- A. SMART CLUSTERS ---
            while(res.includes("{i>")) { res = res.replace("{i>", "à¤·à¥à¤Ÿà¤¿"); }
            while(res.includes("{ÃŽ")) { res = res.replace("{ÃŽ", "à¤¤à¥à¤¤à¤¿"); }
            while(res.includes("{Ã")) { res = res.replace("{Ã", "à¤•à¥à¤¤à¤¿"); }

            // --- B. PRIORITY FIXES (Manual Override) ---
            
            // 1. Ã¼ -> à¤¶à¥à¤š (Nischayatmak)
            // Note: split/join works best for special chars
            res = res.split('Ã¼').join('à¤¶à¥à¤š');

            // 2. Ã· -> à¤¹à¥à¤® (Bramhand) - Updated from 'à¤¹à¥'
            res = res.split('Ã·').join('à¤¹à¥à¤®');

            // 3. Ã¶ -> à¤‚ (Anuswar) - For 'Thayi' dots
            res = res.split('Ã¶').join('à¤‚');

            // 4. Other Standard Fixes
            res = res.split('Ã”').join('à¤¯');
            res = res.split('Ã‡').join('à¤—');
            res = res.replace(/Âº(?!\$)/g, 'à¤¤');
            res = res.split('|').join('à¤¾');
            res = res.split('Â¦').join('à¤¾');
            res = res.split('$').join('à¤³');
            res = res.split('Â£').join('à¥€');
            res = res.split('i').join('à¥€');   

            // 5. Explicit Reph Fix for 'Garbha' (Just in case)
            // Fixes 'à¤­à¤¾Â©' -> 'à¤°à¥à¤­à¤¾' explicitly
            res = res.split('à¤­à¤¾Â©').join('à¤°à¥à¤­à¤¾');
            res = res.split('à¤µà¤¾Â©').join('à¤°à¥à¤µà¤¾');


            // --- C. VELAANTI LOGIC ---
            // { -> à¤¿
            let pos_curly = res.indexOf("{");
            while (pos_curly !== -1) {
                if (pos_curly + 1 < res.length) {
                    let next = res.charAt(pos_curly + 1);
                    if (next !== ' ' && next !== 'Â©') res = res.replace("{" + next, next + "à¤¿");
                }
                pos_curly = res.indexOf("{", pos_curly + 1);
            }
            // > -> à¤¿
            let pos_grt = res.indexOf(">");
            while (pos_grt !== -1) {
                if (pos_grt + 1 < res.length) {
                    let next = res.charAt(pos_grt + 1);
                    if (next !== ' ' && next !== 'Â©') res = res.replace(">" + next, next + "à¤¿");
                }
                pos_grt = res.indexOf(">", pos_grt + 1);
            }
            // [ -> à¤¿
            let pos_sq = res.indexOf("[");
            while (pos_sq !== -1) {
                if (pos_sq + 1 < res.length) {
                    let next = res.charAt(pos_sq + 1);
                    if (next !== ' ' && next !== 'Â©') res = res.replace("[" + next, next + "à¤¿");
                }
                pos_sq = res.indexOf("[", pos_sq + 1);
            }


            // --- D. MAIN MAPPING ---
            for (let i = 0; i < shreelipi_list.length; i++) {
                if (shreelipi_list[i] && unicode_list[i]) {
                    res = res.split(shreelipi_list[i]).join(unicode_list[i]);
                }
            }


            // --- E. POST FIXES ---

            // 'o' Matra
            let pos_o = res.indexOf("o");
            while (pos_o !== -1) {
                if (pos_o + 1 < res.length) {
                    let next = res.charAt(pos_o + 1);
                    if (next !== ' ' && next !== 'à¥') res = res.replace("o" + next, next + "à¤¿");
                }
                pos_o = res.indexOf("o", pos_o + 1);
            }

            // 'q' -> 'o'
            let pos_q = res.indexOf("q");
            while (pos_q !== -1) {
                 if (pos_q + 1 < res.length) {
                    let next = res.charAt(pos_q + 1);
                    res = res.replace("q" + next, next + "o");
                 }
                 pos_q = res.indexOf("q", pos_q + 1);
            }

            // 'o' + Halant
            let pos_oh = res.indexOf("oà¥");
            while (pos_oh !== -1) {
                if (pos_oh + 2 < res.length) {
                    let cons = res.charAt(pos_oh + 2);
                    res = res.replace("oà¥" + cons, "à¥" + cons + "à¤¿à¤‚");
                }
                pos_oh = res.indexOf("oà¥", pos_oh + 3);
            }

            // Cleanup 'o'
            res = res.replace(/o/g, "à¤¿à¤‚");

            // Rafar Logic (Â© -> à¤°à¥)
            const matras = "à¤¾à¤¿à¥€à¥à¥‚à¥ƒà¥‡à¥ˆà¥‹à¥Œà¤‚à¤ƒà¤à¥…";
            let pos_reph = res.indexOf("Â©");
            while (pos_reph > 0) {
                let prob = pos_reph - 1;
                while (prob >= 0 && matras.includes(res.charAt(prob))) prob--;
                if (prob < 0) prob = 0;
                
                let chunk = res.substring(prob, pos_reph);
                res = res.substring(0, prob) + "à¤°à¥" + chunk + res.substring(pos_reph + 1);
                
                pos_reph = res.indexOf("Â©"); // Restart search to ensure all are caught
            }
            
            // Tilde (~) -> à¤°à¥
            let pos_tilde = res.indexOf("~");
             while (pos_tilde > 0) {
                let prob = pos_tilde - 1;
                while (prob >= 0 && matras.includes(res.charAt(prob))) prob--;
                if (prob < 0) prob = 0;
                let chunk = res.substring(prob, pos_tilde);
                res = res.substring(0, prob) + "à¤°à¥" + chunk + res.substring(pos_tilde + 1);
                pos_tilde = res.indexOf("~");
            }

            return res;
        }

        // --- UI HANDLERS ---
        const fileInput = document.getElementById('fileInput');
        const convertBtn = document.getElementById('convertBtn');
        const fileNameDiv = document.getElementById('fileName');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', () => {
            if(fileInput.files.length > 0) {
                fileNameDiv.innerText = "Selected: " + fileInput.files[0].name;
                convertBtn.disabled = false;
            }
        });

        convertBtn.addEventListener('click', async () => {
            convertBtn.disabled = true;
            convertBtn.innerText = "Processing...";
            
            try {
                if (typeof JSZip === 'undefined') throw new Error("Internet Needed.");
                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                if (!zip.file("word/document.xml")) throw new Error("Invalid Docx.");
                const docXml = await zip.file("word/document.xml").async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, "text/xml");
                const textNodes = xmlDoc.getElementsByTagName("w:t");

                for (let i = 0; i < textNodes.length; i++) {
                    let original = textNodes[i].textContent;
                    if (original && original.trim().length > 0) {
                        textNodes[i].textContent = convertText(original);
                    }
                }

                const serializer = new XMLSerializer();
                const newDocXml = serializer.serializeToString(xmlDoc);
                zip.file("word/document.xml", newDocXml);
                const blob = await zip.generateAsync({type: "blob", mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"});
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "Master_V18_" + file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                convertBtn.innerText = "Done! Downloaded.";
                statusDiv.innerText = "Success! (All characters Perfect)";
                statusDiv.style.color = "green";
                setTimeout(() => convertBtn.disabled = false, 2000);

            } catch (err) {
                alert("Error: " + err.message);
                convertBtn.innerText = "Try Again";
                convertBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
