<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShreeLipi Word to Word</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body { font-family: -apple-system, sans-serif; background: #f2f2f7; text-align: center; padding: 20px; }
        .card { background: white; max-width: 500px; margin: 40px auto; padding: 30px; border-radius: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        h2 { color: #1c1c1e; margin-bottom: 5px; }
        p { color: #8e8e93; font-size: 14px; margin-bottom: 30px; }
        
        .upload-box {
            border: 2px dashed #007aff; background: #eef7ff; color: #007aff;
            padding: 40px; border-radius: 15px; font-weight: 600; cursor: pointer;
            margin-bottom: 20px; transition: 0.2s;
        }
        .upload-box:active { background: #dcebff; }
        input[type="file"] { display: none; }

        button {
            background: #007aff; color: white; border: none; padding: 16px; width: 100%;
            border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer;
        }
        button:disabled { background: #d1d1d6; cursor: not-allowed; }
        
        #status { margin-top: 15px; font-size: 14px; color: #333; }
    </style>
</head>
<body>

    <div class="card">
        <h2>Word to Word Converter</h2>
        <p>Keep Formatting, Change Only Text</p>

        <label for="fileInput" class="upload-box">
            üìÑ Select Word File (.docx)
        </label>
        <input type="file" id="fileInput" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
        
        <div id="fileName" style="margin-bottom: 20px; font-weight: 500; display:none;"></div>

        <button id="convertBtn" disabled>Convert Now</button>
        <div id="status"></div>
    </div>

    <script>
        // --- 1. MAPPING LOGIC (SHREELIPI TO UNICODE) ---
        const array_one = ["~","u","¬™","}","n","p","H","¬∑","I","¬ª","J","¬Ω","K","M","√Ä","N","¬µO","O","¬µ√Å","√Å","P","Q","R","¬∂S","S","¬∂T","T","U","√ä","W","√è","V","√ã","Y","√ú","X","Z","√ù","\\","√¢","[","√ü","^","√§","]","√£","_","√•","`","a","c","√´","d","√¨","e","√ª","√≠","f","√Æ","g","√±","h","j","√∫","k","√î","√õ","√ö","√†","√û","Q¬≠","¬∫$","√å","√ê","√ï","l","√ém","¬∏","‚Äû","ÀÜ","≈ì","√Ö","Am¬°","Am{","Am|","Am","A","B¬©","B","C","D","E{","E","F","m¬∞","m{","m|","{","|","m¬°","m¬¢","¬°","¬¢","m","r","s","t","w","√æ","y","¬ß","¬±","‚Ä¢","¬•","¬≤","√ë","¬´","√©","√™","&","$",">","¬µ"];
        const array_two = ["¬©","¬©","¬©‡§Ç","{¬©","o","o","‡§ï","‡§ï‡•ç","‡§ñ","‡§ñ‡•ç","‡§ó","‡§ó‡•ç","‡§ò","‡§ö","‡§ö‡•ç","‡§õ","‡§ú‡§º","‡§ú","‡§ú‡§º‡•ç‚Äå","‡§ú‡•ç","‡§ù","‡§ü","‡§†","‡§°‡§º","‡§°","‡§¢‡§º","‡§¢","‡§£","‡§£‡•ç","‡§•","‡§•‡•ç","‡§§","‡§§‡•ç","‡§ß","‡§ß‡•ç","‡§¶","‡§®","‡§®‡•ç","‡§´","‡§´‡•ç","‡§™","‡§™‡•ç","‡§≠","‡§≠‡•ç","‡§¨","‡§¨‡•ç","‡§Æ","‡§Æ‡•ç","‡§Ø","‡§∞","‡§≤","‡§≤‡•ç","‡§µ","‡§µ‡•ç","‡§∂","‡§∂‡•ç","‡§∂‡•ç","‡§∑","‡§∑‡•ç","‡§∏","‡§∏‡•ç","‡§π","‡§ï‡•ç‡§∑","‡§ï‡•ç‡§∑‡•ç","‡§ú‡•ç‡§û","‡§¶‡•ç‡§¶","‡§¶‡•ç‡§µ","‡§¶‡•ç‡§Ø","‡§™‡•ç‡§∞","‡§®‡•ç‡§®","‡§ü‡•ç‡§∞","‡§ï‡•ç‡§§","‡§§‡•ç‡§∞","‡§¶‡•ç‡§∞","‡§¶‡•ç‡§ß","‡§∂‡•ç‡§∞","‡§§‡•ç‡§§","‡§ï‡•ç‡§ï","‡§≤‡•ç‡§≤","‡§π‡•ç‡§µ","‡§∂‡•ç‡§µ","‡§ü‡•ç‡§ü","‡§î","‡§ì","‡§ì‡§Ç","‡§Ü","‡§Ö","‡§à","‡§á","‡§â","‡§ä","‡§ê","‡§è","‡§ã","‡•â","‡•ã","‡•ã‡§Ç","‡•á","‡•á‡§Ç","‡•å","‡•å‡§Ç","‡•à","‡•à‡§Ç","‡§æ","‡•Ä","‡•Ä","‡•Ä‡§Ç","‡•Å","‡•Å","‡•Ç","‡§Ç","‡§Ç","‡§Å","‡§É","‡•É","‡•ç","‡§¶‡•É","‡•ç‡§∞","‡§∞‡•Å","‡§∞‡•Ç","‡•§","","",""];

        function convertText(text) {
            if (!text) return "";
            let modified = text;

            // 1. Basic Replacement
            for (let i = 0; i < array_one.length; i++) {
                if (array_one[i] && array_two[i]) {
                     // Using split/join for global replacement ensuring special chars are handled
                     modified = modified.split(array_one[i]).join(array_two[i]);
                }
            }

            // 2. 'i' Matra Fix (o -> ‡§ø)
            let pos_i = modified.indexOf("o");
            while (pos_i !== -1) {
                let next_char = modified.charAt(pos_i + 1);
                modified = modified.replace("o" + next_char, next_char + "‡§ø");
                pos_i = modified.indexOf("o", pos_i + 1);
            }

            // 3. 'i' Matra on Half Letters Fix
            let pos_wrong = modified.indexOf("‡§ø‡•ç");
            while (pos_wrong !== -1) {
                let cons = modified.charAt(pos_wrong + 2);
                modified = modified.replace("‡§ø‡•ç" + cons, "‡•ç" + cons + "‡§ø");
                pos_wrong = modified.indexOf("‡§ø‡•ç", pos_wrong + 2);
            }

            // 4. 'q' Fix (q -> o substitution logic)
            let pos_q = modified.indexOf("q");
            while (pos_q !== -1) {
                let next_char = modified.charAt(pos_q + 1);
                modified = modified.replace("q" + next_char, next_char + "o");
                pos_q = modified.indexOf("q", pos_q + 1);
            }

            // 5. 'o' + Halant Fix
            let pos_o_halant = modified.indexOf("o‡•ç");
            while (pos_o_halant !== -1) {
                let cons = modified.charAt(pos_o_halant + 2);
                modified = modified.replace("o‡•ç" + cons, "‡•ç" + cons + "‡§ø‡§Ç");
                pos_o_halant = modified.indexOf("o‡•ç", pos_o_halant + 3);
            }
            
            // Cleanup remaining 'o'
            modified = modified.replace(/o/g, "‡§ø‡§Ç");

            // 6. Reph (Rafar) Fix (¬© -> ‡§∞‡•ç)
            const matras = "‡§æ‡§ø‡•Ä‡•Å‡•Ç‡•É‡•á‡•à‡•ã‡•å‡§Ç‡§É‡§Å‡•Ö";
            let pos_reph = modified.indexOf("¬©");
            while (pos_reph > 0) {
                let prob_pos = pos_reph - 1;
                while (matras.includes(modified.charAt(prob_pos))) {
                    prob_pos--;
                }
                let chunk = modified.substring(prob_pos, pos_reph);
                let before = modified.substring(0, prob_pos);
                let after = modified.substring(pos_reph + 1);
                modified = before + "‡§∞‡•ç" + chunk + after;
                pos_reph = modified.indexOf("¬©", prob_pos + chunk.length + 1);
            }

            return modified;
        }

        // --- 2. FILE HANDLING LOGIC ---
        const fileInput = document.getElementById('fileInput');
        const convertBtn = document.getElementById('convertBtn');
        const fileNameDiv = document.getElementById('fileName');
        const statusDiv = document.getElementById('status');

        fileInput.addEventListener('change', () => {
            if(fileInput.files.length > 0) {
                fileNameDiv.style.display = 'block';
                fileNameDiv.innerText = fileInput.files[0].name;
                convertBtn.disabled = false;
            }
        });

        convertBtn.addEventListener('click', async () => {
            convertBtn.disabled = true;
            convertBtn.innerText = "Processing...";
            statusDiv.innerText = "";

            try {
                if (typeof JSZip === 'undefined') throw new Error("Internet connection needed for library.");
                
                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);

                // Check for document.xml
                if (!zip.file("word/document.xml")) {
                    throw new Error("Invalid .docx file.");
                }

                // Read Content
                const docXml = await zip.file("word/document.xml").async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, "text/xml");
                
                // Find all Text Nodes (<w:t>)
                const textNodes = xmlDoc.getElementsByTagName("w:t");

                let count = 0;
                for (let i = 0; i < textNodes.length; i++) {
                    const original = textNodes[i].textContent;
                    if (original && original.trim() !== "") {
                        // Apply Conversion
                        textNodes[i].textContent = convertText(original);
                        count++;
                    }
                }

                // Serialize back to XML
                const serializer = new XMLSerializer();
                const newDocXml = serializer.serializeToString(xmlDoc);
                zip.file("word/document.xml", newDocXml);

                // Generate Blob (Correct MIME for Word)
                const blob = await zip.generateAsync({
                    type: "blob",
                    mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                });

                // Download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "Converted_" + file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                convertBtn.innerText = "Done! Convert Another";
                statusDiv.innerText = `Success! Converted ${count} text parts.`;

            } catch (err) {
                console.error(err);
                statusDiv.innerText = "Error: " + err.message;
                convertBtn.innerText = "Try Again";
            } finally {
                convertBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
